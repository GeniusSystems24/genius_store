# Use Cases

This directory contains use case classes that encapsulate the business logic of the Genius Store application. Each use case represents a specific action or transaction that a user can perform within the system.

## Purpose

Use cases:

- Encapsulate a single business operation or process
- Orchestrate the flow of data between the UI and the data layer
- Apply business rules and validation
- Handle business-level errors
- Provide a clean API for the presentation layer to execute business operations

## Key Concept: Single Responsibility

Each use case follows the Single Responsibility Principle by focusing on one specific business operation. This approach:

- Makes the codebase more maintainable and testable
- Ensures that business logic is independent of UI concerns
- Allows for easy reuse of business logic across different UI components
- Provides clear documentation of what the application can do

## Structure

A typical use case class follows these conventions:

- Simple class with a single `call()` method (making it callable)
- Depends on one or more repositories
- Accepts parameters specific to the operation
- Returns `Future<Either<Failure, T>>` where T is the result type
- Uses dependency injection for repositories

## Implementation Pattern

The application follows a consistent pattern for all use cases:

```dart
class GetProductsUseCase {
  final ProductRepository repository;

  GetProductsUseCase(this.repository);

  Future<Either<Failure, List<Product>>> call() async {
    return await repository.getProducts();
  }
}

class GetProductByIdUseCase {
  final ProductRepository repository;

  GetProductByIdUseCase(this.repository);

  Future<Either<Failure, Product>> call(String productId) async {
    // Input validation
    if (productId.isEmpty) {
      return Left(ValidationFailure('Product ID cannot be empty'));
    }
    
    return await repository.getProductById(productId);
  }
}

class AddToCartUseCase {
  final CartRepository cartRepository;
  final ProductRepository productRepository;

  AddToCartUseCase({
    required this.cartRepository,
    required this.productRepository,
  });

  Future<Either<Failure, Cart>> call(AddToCartParams params) async {
    // Validate parameters
    if (params.quantity <= 0) {
      return Left(ValidationFailure('Quantity must be greater than zero'));
    }
    
    // Check product availability
    final productResult = await productRepository.getProductById(params.productId);
    
    return await productResult.fold(
      (failure) => Left(failure),
      (product) async {
        // Apply business rules
        if (!product.isActive) {
          return Left(BusinessFailure('Product is not available'));
        }
        
        // Find the specified variant
        final variant = product.variants?.firstWhere(
          (v) => v.id == params.variantId,
          orElse: () => throw NotFoundException('Variant not found'),
        );
        
        if (variant == null) {
          return Left(ValidationFailure('Invalid product variant'));
        }
        
        if (variant.stockQuantity < params.quantity) {
          return Left(BusinessFailure('Not enough items in stock'));
        }
        
        // Add to cart
        return await cartRepository.addItemToCart(
          params.cartId,
          CartItem(
            id: '', // Will be generated by repository
            cartId: params.cartId,
            productId: params.productId,
            variantId: params.variantId,
            quantity: params.quantity,
            price: variant.price,
          ),
        );
      },
    );
  }
}

// Parameters class for complex use cases
class AddToCartParams {
  final String cartId;
  final String productId;
  final String variantId;
  final int quantity;

  AddToCartParams({
    required this.cartId,
    required this.productId,
    required this.variantId,
    required this.quantity,
  });
}
```

## Use Case Categories

The application organizes use cases into categories:

- **Authentication**: Sign-up, login, password reset
- **User Profile**: View/update profile, manage addresses/payment methods
- **Product Browsing**: List/search products, view details, filter by category
- **Shopping Cart**: Create carts, add/remove items, view cart contents
- **Checkout**: Create order, process payment, confirm order
- **Orders**: View order history, track order status
- **Wishlist**: Add to wishlist, remove from wishlist, view wishlist

## Dependency Injection

Use cases are provided to the presentation layer through dependency injection using Riverpod:

```dart
// Define the provider
final getProductsUseCaseProvider = Provider<GetProductsUseCase>((ref) {
  final repository = ref.watch(productRepositoryProvider);
  return GetProductsUseCase(repository);
});

// Use the provider in a widget or view model
final productsUseCase = ref.watch(getProductsUseCaseProvider);
final products = await productsUseCase();
```

## Testing

Use cases should be thoroughly tested:

- Test the application of business rules
- Verify error handling for invalid inputs
- Mock repositories to test various scenarios
- Ensure proper orchestration of multiple repositories

Example:

```dart
void main() {
  late AddToCartUseCase useCase;
  late MockCartRepository mockCartRepository;
  late MockProductRepository mockProductRepository;
  
  setUp(() {
    mockCartRepository = MockCartRepository();
    mockProductRepository = MockProductRepository();
    
    useCase = AddToCartUseCase(
      cartRepository: mockCartRepository,
      productRepository: mockProductRepository,
    );
  });
  
  test('should add item to cart when all conditions are met', () async {
    // Test implementation
  });
  
  test('should return error when product is not available', () async {
    // Test implementation
  });
  
  // More tests...
}
```
